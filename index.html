<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NachoZorra Generator ü¶ä</title>

  <!-- Felt Tip Roman (modo normal) -->
  <link href="https://fonts.cdnfonts.com/css/felt-tip-roman" rel="stylesheet">

  <!-- Preload de la fuente oficial Brat (Arial Narrow real) -->
  <link rel="preload" 
        href="https://www.bratgenerator.com/sites/g/files/g2000017981/files/2024-03/arial_narrow-webfont.woff"
        as="font" 
        type="font/woff" 
        crossorigin>

  <!-- Fuente oficial Brat: Arial Narrow REAL -->
  <style>
    @font-face {
      font-family: 'arial_narrowregular';
      src: url('https://www.bratgenerator.com/sites/g/files/g2000017981/files/2024-03/arial_narrow-webfont.woff') format('woff');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
  </style>

  <style>
  @font-face {
    font-family: 'OPTICashew-ExtraBold';
    src: url('assets/OPTICashew-ExtraBold.woff') format('woff');
    font-weight: 800;
  }
  </style>
  <style>
  @font-face {
    font-family: 'Blacksword';
    src: url('assets/diplomatic.otf') format('opentype');
    font-weight: normal;
    font-style: normal;
  }
  </style>


  <!-- Tailwind para layout de controles -->
  <script src="https://cdn.tailwindcss.com"></script>
<style>
  :root {
    --controls-h: 110px;
  }

  html, body {
  height: 100dvh;
  overflow: hidden;
  }


  body {
    background: #111;
    margin: 0;
    color: #fff;
    font-family: 'Felt Tip Roman', cursive;
    overflow: hidden;
  }

  /* √Årea de preview */
  #stage {
    height: calc(100vh - var(--controls-h));
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #previewCanvas {
    width: min(90vw, 90vh);
    height: min(90vw, 90vh);
    box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    border-radius: 25px;
    background: #fff;
    display: block;
  }

  /* Panel de control inferior */
  .control-panel {
    position: fixed;
    bottom: 0;
    width: 100%;
    height: var(--controls-h);
    background: rgba(0,0,0,0.88);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 6px;
    z-index: 20;
    padding-bottom: 90px;
  }

  .control-panel {
    padding-bottom: calc(env(safe-area-inset-bottom) + 12px);
  }

  #multiBtn {
    margin-bottom: calc(env(safe-area-inset-bottom) + 90px);
  }



  /* Switch tipo iPhone */
  .switch {
    position: relative;
    width: 55px;
    height: 28px;
  }
  .switch input { display:none; }

  .slider {
    position: absolute;
    cursor: pointer;
    inset: 0;
    background-color: #555;
    transition: .3s;
    border-radius: 34px;
  }
  .slider:before {
    content: "";
    position: absolute;
    height: 22px;
    width: 22px;
    left: 3px;
    bottom: 3px;
    background: #fff;
    transition: .3s;
    border-radius: 50%;
  }
  input:checked + .slider {
    background-color: #22c55e;
  }
  input:checked + .slider:before {
    transform: translateX(26px);
  }

  /* Input de color */
  #bgColor {
    width: 34px;
    height: 34px;
    padding: 0;
    border-radius: 999px;
    border: none;
    overflow: hidden;
  }
  #bgColor::-webkit-color-swatch,
  #bgColor::-moz-color-swatch {
    border: none;
    border-radius: 999px;
  }

  /* =========================================
            RESPONSIVE PARA CELULARES
     ========================================= */
  @media (max-width: 480px) {

    /* Aumentamos la altura para que todo quepa */
    :root {
      --controls-h: 160px;
    }

    /* Panel en vertical */
    .control-panel {
      height: var(--controls-h);
      flex-direction: column;
      gap: 10px;
      padding: 10px 8px;
    }

    /* Segunda fila: input + color + bot√≥n ‚Üí vertical */
    .control-panel > div:nth-child(2) {
      display: flex;
      flex-direction: column;
      gap: 8px !important;
      width: 100%;
      padding: 0 10px;
    }

    /* Input ocupa todo el ancho */
    #textInput {
      width: 100% !important;
      font-size: 16px !important;
      padding: 8px !important;
    }

    /* Bot√≥n ocupa todo el ancho */
    #downloadBtn {
      width: 100%;
      padding: 8px !important;
      font-size: 14px !important;
    }

    /* Color picker m√°s peque√±o */
    #bgColor {
      width: 28px !important;
      height: 28px !important;
    }

  }
</style>

</head>
<body>

  <main id="stage">
    <canvas id="previewCanvas" width="1080" height="1080"></canvas>
  </main>

  <!-- Controles -->
  <div class="control-panel">
    <!-- Modo -->
    <div class="flex items-center justify-center gap-3 text-sm">
      <span>Modo:</span>
    
      <select id="modeSelect" class="p-2 rounded-lg text-black font-bold">
        <option value="normal">Normal</option>
        <option value="brat">Brat</option>
        <option value="crudo">Crudo</option>
        <option value="elegante">Elegante</option>

      </select>
    
      <span id="modeLabel">Normal</span>
    </div>


    <!-- Texto + fondo + bot√≥n -->
    <div class="flex items-center justify-center gap-3 w-full px-3">
      <input
        id="textInput"
        type="text"
        placeholder="Escribe tu frase..."
        class="flex-1 p-2 rounded-lg text-black text-center font-bold text-lg outline-none"
      >

      <div class="flex items-center gap-1 text-sm">
        <span>Fondo:</span>
        <input type="color" id="bgColor" value="#ffffff">
      </div>

      <button
        id="downloadBtn"
        class="px-5 py-2 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 active:bg-indigo-800"
      >
        Descargar PNG
      </button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("previewCanvas");
    const ctx = canvas.getContext("2d");
    // Marca de agua como imagen
    const watermarkImage = new Image();
    watermarkImage.src = "assets/marca.png?v=1"; // cache-buster
    watermarkImage.onload = draw;
    const eleganteLogo = new Image();
    eleganteLogo.src = "assets/logo-elegante.png?v=1";
    eleganteLogo.onload = draw;



    const input = document.getElementById("textInput");
    const bgColorInput = document.getElementById("bgColor");
    const modeSelect = document.getElementById("modeSelect");
    const modeLabel = document.getElementById("modeLabel");
    const downloadBtn = document.getElementById("downloadBtn");

    const CANVAS_SIZE = 1080;
    const PADDING = window.innerWidth < 600 ? 14 : 20;
    const BRAT_STRETCH_Y = 1.3; // alto de letras en modo brat

    // Eventos
    window.addEventListener("load", draw);
    document.fonts.ready.then(draw);

    input.addEventListener("input", draw);
    bgColorInput.addEventListener("input", draw);
    modeSelect.addEventListener("change", () => {
      const v = modeSelect.value;

      if (v === "brat") modeLabel.textContent = "Brat";
      else if (v === "crudo") modeLabel.textContent = "Crudo";
      else if (v === "elegante") modeLabel.textContent = "Elegante";
      else modeLabel.textContent = "Normal";

      draw();
    });

    downloadBtn.addEventListener("click", downloadPNG);

    // Bot√≥n para m√∫ltiples frases
    const multiBtn = document.createElement("button");
    multiBtn.innerText = "Generar m√∫ltiples";
    multiBtn.className =
      "px-4 py-2 bg-pink-600 text-white text-sm rounded-lg shadow-md hover:bg-pink-700 active:bg-pink-800";
    multiBtn.onclick = generateMultiple;
    document.querySelector(".control-panel").appendChild(multiBtn);

    function draw() {
      const text = input.value.trim();
      const bg = bgColorInput.value;
      const mode = modeSelect.value;

      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      if (!text) {
        drawPlaceholder();
        return;
      }

      if (mode === "elegante") {
        drawElegante(text);
      } else {
        // fondo normal para otros modos
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

        drawWatermark();
        drawAEStyleText();

        if (mode === "brat") drawBrat(text, bg);
        else if (mode === "crudo") drawCrudo(text, bg);
        else drawNormal(text, bg);
      }

      // Tags
      if (mode === "brat") drawCornerTagBrat();
      else if (mode === "crudo") drawCornerTagCrudo();
      else if (mode === "elegante") drawCornerTagElegante();
      else drawCornerTagNormal();
    }




    /* ========= MODO NORMAL (con caja estilo BRAT) ========= */
    function drawNormal(text, bg) {
      ctx.save();

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getContrastColor(bg);

      // === Caja igual al estilo BRAT ===
      const boxWidth  = CANVAS_SIZE * 0.85;   // m√°s angosto ‚Üí m√°s vertical
      const boxHeight = CANVAS_SIZE * 0.90;   // ocupa casi todo el alto

      const boxX = (CANVAS_SIZE - boxWidth) / 2;
      const boxY = (CANVAS_SIZE - boxHeight) / 2;

      // === Tama√±os de letra m√°s grandes ===
      const maxFont = 130;
      const minFont = 40;

      let fontSize = maxFont;
      let lines = [];

      // === Ajuste autom√°tico de tama√±o ===
      while (fontSize > minFont) {
        ctx.font = `${fontSize}px 'Felt Tip Roman', cursive`;
        lines = wrapText(text, boxWidth, ctx);

        const totalHeight = lines.length * fontSize * 1.1;

        if (totalHeight <= boxHeight) break;  // cabe perfecto dentro del ‚Äúbox‚Äù

        fontSize -= 4;
      }

      // === Aplicar fuente final ===
      ctx.font = `${fontSize}px 'Felt Tip Roman', cursive`;
      lines = wrapText(text, boxWidth, ctx);

      // === C√°lculo consistente del interlineado ===
      const lineHeight = fontSize * 1;     // ‚Üê mismo valor que en el dibujo
      const totalHeight = lines.length * lineHeight;

      // === Centrado vertical real ===
      let y = boxY + (boxHeight - totalHeight) / 2 + lineHeight / 2;

      // === Activar sombra suave (antes de dibujar las l√≠neas) ===
      ctx.shadowColor = "rgba(0,0,0,0.20)";
      ctx.shadowBlur = 5;
      ctx.shadowOffsetX = 4;
      ctx.shadowOffsetY = 4;


      // === Dibujar texto l√≠nea por l√≠nea ===
      for (const line of lines) {
        ctx.strokeStyle = ctx.fillStyle;
        ctx.lineWidth = 2.35;
        ctx.strokeText(line, CANVAS_SIZE / 2, y);
        ctx.fillText(line, CANVAS_SIZE / 2, y);

        y += lineHeight;
      }


      ctx.restore();
    }


    function drawElegante(text) {
      ctx.save();

      // ==========================
      // 1. FONDO NEGRO
      // ==========================
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);


      // ==========================
      // 2. LOGO DE FONDO (tipo watermark)
      // ==========================
      if (eleganteLogo && eleganteLogo.complete) {

        const size = CANVAS_SIZE * 1.1;

        // Canvas temporal para sombra + composici√≥n limpia
        const temp = document.createElement("canvas");
        temp.width = CANVAS_SIZE;
        temp.height = CANVAS_SIZE;
        const tctx = temp.getContext("2d");

        tctx.save();

        // Sombra suave elegante
        tctx.shadowColor = "rgba(0,0,0,0.40)";
        tctx.shadowBlur = 8;
        tctx.shadowOffsetX = 4;
        tctx.shadowOffsetY = 4;

        // Centrado matem√°tico perfecto
        tctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
        tctx.drawImage(
          eleganteLogo,
          -size / 2,
          -size / 2,
          size,
          size
        );

        tctx.restore();

        // Aplicar opacidad final
        ctx.save();
        ctx.globalAlpha = 0.1;  // Ajusta aqu√≠ si lo quieres m√°s visible
        ctx.drawImage(temp, 0, 0);
        ctx.restore();
      }


      // ==========================
      // 3. TEXTO PRINCIPAL
      // ==========================
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "#ffffff";

      const boxWidth  = CANVAS_SIZE * 0.70;
      const boxHeight = CANVAS_SIZE * 0.60;

      const maxFont = 150;
      const minFont = 40;

      let fontSize = maxFont;
      let lines = [];

      while (fontSize > minFont) {
        ctx.font = `${fontSize}px 'Blacksword'`;
        lines = wrapText(text, boxWidth, ctx);

        const totalHeight = lines.length * fontSize * 0.95;

        if (totalHeight <= boxHeight) break;

        fontSize -= 4;
      }

      ctx.font = `${fontSize}px 'Blacksword'`;
      lines = wrapText(text, boxWidth, ctx);

      const lineHeight = fontSize * 0.92;
      const totalHeight = lines.length * lineHeight;

      let y = CANVAS_SIZE / 2 - totalHeight / 2 + lineHeight / 2;

      for (const line of lines) {
        ctx.fillText(line, CANVAS_SIZE / 2, y);
        y += lineHeight;
      }


      // ==========================
      // 4. SUBRAYADO VIXEVEL
      // ==========================
      const underlineY = y + 10;
      const centerX = CANVAS_SIZE / 2;

      ctx.lineCap = "round";
      ctx.strokeStyle = "#ffffff";

      ctx.restore();
    }


    function drawCrudo(text, bg) {
      ctx.save();
    
      // 1) Fondo base: ignoramos el bg picker o lo "suavizamos"
      // Si quieres que el color picker siga mandando, comenta estas dos l√≠neas.
      const paperBase = "#F3EEE6"; // lo lleva hacia blanco/hueso
      ctx.fillStyle = paperBase;
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
      // 2) Textura de papel (procedural)
      drawPaperTexture();
    
      // 3) Texto: may√∫sculas y bloque fuerte
      const raw = (text || "").trim();
      const t = raw.toUpperCase();
    
      // Caja para texto (estilo "bloque plantado")
      const boxWidth  = CANVAS_SIZE * 0.68;
      const boxHeight = CANVAS_SIZE * 0.42;
      const boxX = (CANVAS_SIZE - boxWidth) / 2;
      const boxY = (CANVAS_SIZE - boxHeight) / 2;
    
      // Color tinta: en crudo no depende del contraste puro; usamos "tinta quemada"
      const ink = pickInkColorFromBackground(paperBase);
    
      // Fuente: usamos una stack segura. Si quieres una fuente espec√≠fica,
      // la cargamos igual que tus otras.
      const fontFamily = "Impact, 'Arial Black', 'Helvetica Neue', Arial, sans-serif";
    
      // Autosize + wrapping
      const maxFont = 190;
      const minFont = 40;
      let fontSize = maxFont;
      let lines = [];
    
      while (fontSize > minFont) {
        ctx.font = `${fontSize}px ${fontFamily}`;
        lines = wrapText(t, boxWidth, ctx);
        const lh = fontSize * 0.92;
        const totalH = lines.length * lh;
        if (totalH <= boxHeight) break;
        fontSize -= 4;
      }
    
      // Dibujo "tinta" con ligera imperfecci√≥n
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
    
      const lineHeight = fontSize * 0.92;
      const totalHeight = lines.length * lineHeight;
      let y = boxY + (boxHeight - totalHeight) / 2 + lineHeight / 2;
    
      // Sombra m√≠nima (no ‚Äúglow‚Äù)
      // === SOMBRA SUAVE EDITORIAL (CRUDO) ===
      ctx.shadowColor = "rgba(0,0,0,0.10)";
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;

    
      // ‚ÄúTinta‚Äù: dibujamos 2 pasadas con micro-jitter + grano
      for (const line of lines) {
        drawInkText(line, CANVAS_SIZE / 2, y, ink, fontSize);
        y += lineHeight;
      }
    
      ctx.restore();
    }
    
    /* ======== Textura de papel: noise procedural ======== */
    function drawPaperTexture() {
      const img = ctx.createImageData(CANVAS_SIZE, CANVAS_SIZE);
      const d = img.data;
    
      // Densidad de grano (sube a 0.12 si quieres m√°s textura)
      const strength = 0.06;
    
      for (let i = 0; i < d.length; i += 4) {
        const n = (Math.random() - 0.5) * 255 * strength; // -..+
        d[i]     = clamp(d[i] + n, 0, 255);
        d[i + 1] = clamp(d[i + 1] + n, 0, 255);
        d[i + 2] = clamp(d[i + 2] + n, 0, 255);
        d[i + 3] = 255;
      }
    
      // Mezcla con baja opacidad para no ‚Äúensuciar‚Äù de m√°s
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.putImageData(img, 0, 0);
      ctx.restore();
    
      // Un ‚Äúvignette‚Äù suave para profundidad
      ctx.save();
      const g = ctx.createRadialGradient(
        CANVAS_SIZE/2, CANVAS_SIZE/2, CANVAS_SIZE*0.15,
        CANVAS_SIZE/2, CANVAS_SIZE/2, CANVAS_SIZE*0.75
      );
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.14)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,CANVAS_SIZE,CANVAS_SIZE);
      ctx.restore();
    }
    
    /* ======== Texto con efecto de "tinta" original ======== */
    function drawInkText(line, x, y, inkColor, fontSize) {
      ctx.save();
      ctx.fillStyle = inkColor;
    
      // Pasada 1 (normal)
      ctx.fillText(line, x, y);
    
      // Pasada 2 (micro jitter + alpha)
      ctx.globalAlpha = 0.55;
      const jx = (Math.random() - 0.5) * 2.2;
      const jy = (Math.random() - 0.5) * 2.2;
      ctx.fillText(line, x + jx, y + jy);
    
      // Pasada 3 (un pel√≠n de ‚Äúdesgaste‚Äù con stroke finito)
      ctx.globalAlpha = 0.35;
      ctx.lineWidth = Math.max(2, fontSize * 0.03);
      ctx.strokeStyle = inkColor;
      ctx.strokeText(line, x, y);
    
      ctx.restore();
    }
    






    /* ======== Helpers ======== */
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    
    function softenHex(hex, amountToWhite=0.8){
      // amountToWhite: 0 => igual, 1 => blanco
      const rgb = hexToRgb(hex);
      const r = Math.round(rgb.r + (255 - rgb.r) * amountToWhite);
      const g = Math.round(rgb.g + (255 - rgb.g) * amountToWhite);
      const b = Math.round(rgb.b + (255 - rgb.b) * amountToWhite);
      return rgbToHex(r,g,b);
    }
    
    function pickInkColorFromBackground(bgHex){
      // tinta ‚Äúquemada‚Äù que funciona con fondos claros
      // (si el fondo ya es oscuro, devolvemos casi blanco)
      const c = getContrastColor(bgHex);
      if (c === "#ffffff") return "rgba(245,245,245,0.92)";
      // tinta roja/negra "propia"
      return "rgba(140, 24, 18, 0.92)"; // rojo quemado original
    }
    
    function hexToRgb(hex){
      hex = hex.replace("#","");
      return {
        r: parseInt(hex.slice(0,2),16),
        g: parseInt(hex.slice(2,4),16),
        b: parseInt(hex.slice(4,6),16),
      };
    }
    
    function rgbToHex(r,g,b){
      return "#" + [r,g,b].map(v => v.toString(16).padStart(2,"0")).join("");
    }

    
    /* ========= UTILIDADES DE TEXTO ========= */

    function wrapText(text, maxWidth, ctxLocal) {
      const words = text.split(/\s+/);
      const lines = [];
      let line = "";

      for (const w of words) {
        const testLine = line ? line + " " + w : w;
        const { width } = ctxLocal.measureText(testLine);
        if (width > maxWidth && line) {
          lines.push(line);
          line = w;
        } else {
          line = testLine;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    // Para brat: cada l√≠nea es array de palabras
    function wrapWordsToLines(text, maxWidth, ctxLocal) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let current = [];

      // --- 1. Wrap codicioso normal ---
      words.forEach(w => {
        const test = [...current, w].join(" ");
        const width = ctxLocal.measureText(test).width;
        if (width > maxWidth && current.length > 0) {
          lines.push(current);
          current = [w];
        } else {
          current.push(w);
        }
      });

      if (current.length) lines.push(current);

      // --- 2. Balanceo: evitar l√≠neas de 1 palabra si se puede ---
      const naturalSpace = ctxLocal.measureText(" ").width;

      function lineWidth(line) {
        if (!line.length) return 0;
        const wordsWidth = line.reduce(
          (acc, w) => acc + ctxLocal.measureText(w).width,
          0
        );
        const gaps = line.length - 1;
        return wordsWidth + gaps * naturalSpace;
      }

      // Recorremos de arriba hacia abajo,
      // moviendo palabras de la siguiente l√≠nea a la actual
      for (let i = 0; i < lines.length - 1; i++) {
        let line = lines[i];
        let next = lines[i + 1];

        // Mientras esta l√≠nea tenga 1 palabra
        // y la siguiente tenga al menos 2, intentamos subir una palabra
        while (line.length === 1 && next && next.length >= 2) {
          const candidate = [...line, next[0]];
          if (lineWidth(candidate) <= maxWidth) {
            // S√≠ cabe: subimos la primera palabra de la siguiente l√≠nea
            line = candidate;
            next = next.slice(1);
            lines[i] = line;
            if (next.length) {
              lines[i + 1] = next;
            } else {
              // Si dejamos vac√≠a la siguiente l√≠nea, la quitamos
              lines.splice(i + 1, 1);
              break;
            }
          } else {
            // No cabe "no est√°" juntos, nos quedamos como estamos
            break;
          }
        }
      }

      return lines;
    }


    // Justificado real: ajusta solo espacios, no el tama√±o de las letras
    function drawJustifiedLine(words, x, y, lineWidth, ctx) {
      if (!words || words.length === 0) return;

      ctx.save();
      ctx.filter = "blur(5px)";
      ctx.textBaseline = "top";

      const gaps = words.length - 1;
      const wordWidths = words.map(w => ctx.measureText(w).width);
      const wordsWidth = wordWidths.reduce((a, b) => a + b, 0);

      // Una sola palabra: no podemos justificar sin deformar ‚Üí pegada a la izquierda
      if (gaps === 0) {
        ctx.fillText(words[0], x, y);
        ctx.restore();
        return;
      }

      // Espacio libre que hay que repartir en los huecos
      const freeSpace = lineWidth - wordsWidth;

      let spaceSize;
      if (freeSpace <= 0) {
        // L√≠nea ya muy llena ‚Üí usamos espacio natural
        spaceSize = ctx.measureText(" ").width;
      } else {
        // üíö Justificado real: repartimos TODO el espacio libre entre los huecos
        spaceSize = freeSpace / gaps;
      }

      let cursorX = x;
      for (let i = 0; i < words.length; i++) {
        const w = words[i];
        ctx.fillText(w, cursorX, y);
        if (i < gaps) {
          cursorX += wordWidths[i] + spaceSize;
        }
      }

      ctx.restore();
    }

    // Misma l√≠nea, pero estirada verticalmente (letras m√°s altas)
    function drawJustifiedLineTall(words, x, y, lineWidth, ctx) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(1, BRAT_STRETCH_Y);
      drawJustifiedLine(words, 0, 0, lineWidth, ctx);
      ctx.restore();
    }

    /* ========= WATERMARK logo ========= */
    function drawWatermark() {
      if (!watermarkImage.complete) return;

      const size = CANVAS_SIZE * 1.1;

      // Canvas temporal para componer sombra + imagen con alpha 1.0
      const temp = document.createElement("canvas");
      temp.width = CANVAS_SIZE;
      temp.height = CANVAS_SIZE;
      const tctx = temp.getContext("2d");

      tctx.save();

      // === SOMBRA IGUAL A LA DEL TEXTO ===
      tctx.shadowColor = "rgba(0,0,0,0.40)";
      tctx.shadowBlur = 8;
      tctx.shadowOffsetX = 4;
      tctx.shadowOffsetY = 4;

      // === DIBUJAR PNG CENTRADO (con sombra) ===
      tctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
      tctx.drawImage(
        watermarkImage,
        -size / 2,
        -size / 2,
        size,
        size
      );

      tctx.restore();

      // === AHORA APLICAMOS LA OPACIDAD FINAL ===
      ctx.save();
      ctx.globalAlpha = 0.06;  // << ESTA ES LA √öNICA OPACIDAD
      ctx.drawImage(temp, 0, 0);
      ctx.restore();
    }

    /* ========= PLACEHOLDER ========= */
    function drawPlaceholder() {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.font = "42px 'Felt Tip Roman', cursive";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        "V76ü¶ä",
        CANVAS_SIZE / 2,
        CANVAS_SIZE / 2
      );
      ctx.restore();
    }


    function drawAEStyleText() {
      const textLines = ["\u00A0\u00A0\u00A0\u00A0\u00A0NACHO", "ZORRA"];

      // ==================================================
      // 1. Canvas temporal para fabricar el STROKE OUTSIDE
      // ==================================================
      const temp = document.createElement("canvas");
      temp.width = CANVAS_SIZE;
      temp.height = CANVAS_SIZE;
      const tctx = temp.getContext("2d");

      const x = CANVAS_SIZE / 2 + 220;  // << mueve todo a la derecha
      const y = CANVAS_SIZE * 0.78 - 15;

      const fontSize = 90;
      const lineSpacing = fontSize * 0.9;

      tctx.font = `${fontSize}px 'OPTICashew-ExtraBold'`;
      tctx.textAlign = "center";
      tctx.textBaseline = "middle";
      tctx.globalAlpha = 1.0; // alpha se aplica luego

      // -------------- Stroke total (dentro y fuera) --------------
      tctx.strokeStyle = "black";
      tctx.lineWidth = 16;  // equivalente aproximado a StrokeWidth=8 de AE

      for (let i = 0; i < textLines.length; i++) {
        const ly = y + (i - 0.5) * lineSpacing;
        tctx.strokeText(textLines[i], x, ly);
      }

      // -------------- Borrar interior (solo deja fuera) --------------
      tctx.globalCompositeOperation = "destination-out";

      for (let i = 0; i < textLines.length; i++) {
        const ly = y + (i - 0.5) * lineSpacing;
        tctx.fillText(textLines[i], x, ly);
      }

      // ==================================================
      // 2. Canvas final para sombra + relleno (como AE)
      // ==================================================
      const finalCanvas = document.createElement("canvas");
      finalCanvas.width = CANVAS_SIZE;
      finalCanvas.height = CANVAS_SIZE;
      const fctx = finalCanvas.getContext("2d");

      // -------- Sombra estilo After Effects --------
      fctx.shadowColor = "rgba(0,0,0,0.80)";   // parecido a opacityPct:128
      fctx.shadowBlur = 5;                     // softness=5
      fctx.shadowOffsetX = 4;                 // direcci√≥n 135¬∞
      fctx.shadowOffsetY = 4;                  // distancia 6 px aprox

      // borde externo con sombra
      fctx.drawImage(temp, 0, 0);

      // quitar sombra antes del relleno
      fctx.shadowBlur = 0;

      // -------- Relleno blanco --------
      fctx.globalAlpha = 1.0;
      fctx.fillStyle = "white";
      fctx.font = `${fontSize}px 'OPTICashew-ExtraBold'`;
      fctx.textAlign = "center";
      fctx.textBaseline = "middle";

      for (let i = 0; i < textLines.length; i++) {
        const ly = y + (i - 0.5) * lineSpacing;
        fctx.fillText(textLines[i], x, ly);
      }

      // ==================================================
      // 3. Alpha global bajo (marca de agua) y draw final
      // ==================================================
      ctx.save();
      ctx.globalAlpha = 0.06;   // <<<<<< EXACTO como pediste
      ctx.drawImage(finalCanvas, 0, 0);
      ctx.restore();
    }

    /* ========= Marca inferior derecha estilo BRAT con sombra din√°mica ========= */
    function drawCornerTagBrat() {
      const tag = "@nachozorra";

      ctx.save();

      // === POSICI√ìN ===
      const padding = 45;
      const x = CANVAS_SIZE - padding;
      const y = CANVAS_SIZE - padding;

      // === BLUR REAL SUAVE ===
      ctx.filter = "blur(2px)";

      // === CALCULAR CONTRASTE SEG√öN EL FONDO ===
      const bg = bgColorInput.value;
      const textColor = getContrastColor(bg); // blanco o negro

      // === SOMBRA DIN√ÅMICA ===
      // Si el texto es blanco ‚Üí sombra clara
      // Si el texto es negro ‚Üí sombra negra
      const shadowColor = (textColor === "#ffffff")
        ? "rgba(255,255,255,0.45)"
        : "rgba(0,0,0,0.45)";

      ctx.shadowColor = shadowColor;
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      // === FUENTE BRAT ===
      const fontSize = 35;
      ctx.font = `${fontSize}px arial_narrowregular, 'Arial Narrow', sans-serif`;
      ctx.textAlign = "right";
      ctx.textBaseline = "bottom";

      // === COLORES DEL TEXTO ===
      ctx.fillStyle = textColor;
      ctx.strokeStyle = textColor === "#000000" ? "#ffffff" : "#000000";
      ctx.lineWidth = 4;

      // === ESTIRAMIENTO BRAT ===
      ctx.translate(x, y);
      ctx.scale(1, BRAT_STRETCH_Y);
      ctx.translate(-x, -y);

      // === DIBUJAR TEXTO ===
      ctx.strokeText(tag, x, y);
      ctx.fillText(tag, x, y);

      ctx.restore();
    }

    /* ========= Marca inferior derecha para MODO NORMAL ========= */
    function drawCornerTagNormal() {
      const tag = "@nachozorra";

      ctx.save();

      // === POSICI√ìN EXACTA ===
      const padding = 45;
      const x = CANVAS_SIZE - padding;
      const y = CANVAS_SIZE - padding;

      // === SOMBRA DIN√ÅMICA (igual que BRAT) ===
      const bg = bgColorInput.value;
      const textColor = getContrastColor(bg);

      const shadowColor = (textColor === "#ffffff")
        ? "rgba(255,255,255,0.45)"     // sombra clara si texto blanco
        : "rgba(0,0,0,0.45)";          // sombra oscura si texto negro

      ctx.shadowColor = shadowColor;
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      // === FUENTE NORMAL: Felt Tip Roman ===
      const fontSize = 42;
      ctx.font = `${fontSize}px 'Felt Tip Roman', cursive`;
      ctx.textAlign = "right";
      ctx.textBaseline = "bottom";

      // === COLOR (contraste din√°mico) ===
      ctx.fillStyle = textColor;

      // Contorno suave
      ctx.strokeStyle = textColor === "#000000" ? "#ffffff" : "#000000";
      ctx.lineWidth = 3;

      // === DIBUJAR ===
      ctx.strokeText(tag, x, y);
      ctx.fillText(tag, x, y);

      ctx.restore();
    }

    /* ========= Marca inferior derecha para MODO ELEGANTE ========= */
    function drawCornerTagElegante() {
      const tag = "@vixevel";

      ctx.save();

      // üî• Resetear cualquier transformaci√≥n previa
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      const x = CANVAS_SIZE / 2;   // centro real horizontal
      const y = CANVAS_SIZE - 80;  // margen inferior elegante

      const fontSize = 90;
      ctx.font = `${fontSize}px 'Blacksword'`;

      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";

      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";

      ctx.fillStyle = "#ffffff";

      ctx.fillText(tag, x, y);

      ctx.restore();
    }



    /* ========= CONTRASTE ========= */
    function getContrastColor(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 150 ? "#000000" : "#ffffff";
    }

    /* ========= DESCARGAR ========= */
    function downloadPNG() {
      const link = document.createElement("a");
      const mode = modeSelect.value;
      link.download = "nachozorra_" + mode + "_" + Date.now() + ".png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }

    function generateMultiple() {
      const raw = input.value;
      const phrases = raw.split("/").map(t => t.trim()).filter(t => t.length > 0);

      if (phrases.length <= 1) {
        alert("Escribe varias frases separadas por /");
        return;
      }

      let index = 0;
      const original = raw;

      function next() {
        if (index >= phrases.length) {
          input.value = original;
          draw();
          alert("Listo: todas las im√°genes fueron generadas.");
          return;
        }

        const phrase = phrases[index];
        input.value = phrase;
        draw();

        setTimeout(() => {
          const link = document.createElement("a");
          link.download = "frase_" + (index + 1) + ".png";
          link.href = canvas.toDataURL("image/png");
          link.click();

          index++;
          next();
        }, 250);
      }

      next();
    }
  </script>

</body>
</html>
