<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NachoZorra Generator ü¶ä</title>

  <!-- Fuentes -->
  <link href="https://fonts.cdnfonts.com/css/felt-tip-roman" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Narrow:wght@400;500;600;700&display=swap" rel="stylesheet">


  <!-- Tailwind para layout de controles -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root {
      --controls-h: 110px;
    }

    body {
      background: #111;
      margin: 0;
      color: #fff;
      font-family: 'Felt Tip Roman', cursive;
      overflow: hidden;
    }

    /* √Årea de preview */
    #stage {
      height: calc(100vh - var(--controls-h));
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #previewCanvas {
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      border-radius: 25px;
      background: #fff;
      display: block;
    }

    /* Panel de control inferior */
    .control-panel {
      position: fixed;
      bottom: 0;
      width: 100%;
      height: var(--controls-h);
      background: rgba(0,0,0,0.88);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      z-index: 20;
      padding-bottom: 6px;
    }

    /* Switch tipo iPhone */
    .switch {
      position: relative;
      width: 55px;
      height: 28px;
    }
    .switch input { display:none; }

    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background-color: #555;
      transition: .3s;
      border-radius: 34px;
    }
    .slider:before {
      content: "";
      position: absolute;
      height: 22px;
      width: 22px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      transition: .3s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #22c55e;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }

    /* Input de color */
    #bgColor {
      width: 34px;
      height: 34px;
      padding: 0;
      border-radius: 999px;
      border: none;
      overflow: hidden;
    }
    #bgColor::-webkit-color-swatch,
    #bgColor::-moz-color-swatch {
      border: none;
      border-radius: 999px;
    }
  </style>
</head>
<body>

  <main id="stage">
    <canvas id="previewCanvas" width="1080" height="1080"></canvas>
  </main>

  <!-- Controles -->
  <div class="control-panel">
    <!-- Modo -->
    <div class="flex items-center justify-center gap-3 text-sm">
      <span>Modo:</span>
      <label class="switch">
        <input type="checkbox" id="modeToggle">
        <span class="slider"></span>
      </label>
      <span id="modeLabel">Normal</span>
    </div>

    <!-- Texto + fondo + bot√≥n -->
    <div class="flex items-center justify-center gap-3 w-full px-3">
      <input
        id="textInput"
        type="text"
        placeholder="Escribe tu frase..."
        class="flex-1 p-2 rounded-lg text-black text-center font-bold text-lg outline-none"
      >

      <div class="flex items-center gap-1 text-sm">
        <span>Fondo:</span>
        <input type="color" id="bgColor" value="#ffffff">
      </div>

      <button
        id="downloadBtn"
        class="px-5 py-2 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 active:bg-indigo-800"
      >
        Descargar PNG
      </button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("previewCanvas");
    const ctx = canvas.getContext("2d");

    const input = document.getElementById("textInput");
    const bgColorInput = document.getElementById("bgColor");
    const toggle = document.getElementById("modeToggle");
    const modeLabel = document.getElementById("modeLabel");
    const downloadBtn = document.getElementById("downloadBtn");

    const CANVAS_SIZE = 1080;
    const PADDING = window.innerWidth < 600 ? 14 : 20;


    // üìå Igual que tu versi√≥n que funciona: esperamos a que carguen las fuentes
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => draw());
    } else {
      window.onload = draw;
    }

    input.addEventListener("input", draw);
    bgColorInput.addEventListener("input", draw);
    toggle.addEventListener("change", () => {
      modeLabel.textContent = toggle.checked ? "Brat" : "Normal";
      draw();
    });
    downloadBtn.addEventListener("click", downloadPNG);

    /* Crear bot√≥n para generar m√∫ltiples */
    const multiBtn = document.createElement("button");
    multiBtn.innerText = "Generar m√∫ltiples";
    multiBtn.className =
      "px-4 py-2 bg-pink-600 text-white text-sm rounded-lg shadow-md hover:bg-pink-700 active:bg-pink-800";
    multiBtn.onclick = generateMultiple;

    /* Insertarlo dentro del panel de controles */
    document.querySelector(".control-panel").appendChild(multiBtn);



    function draw() {
      const text = input.value.trim();
      const bg = bgColorInput.value;

      // Fondo
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      // Watermark siempre detr√°s
      drawWatermark();

      if (!text) {
        drawPlaceholder();
        return;
      }

      if (toggle.checked) {
        drawBrat(text, bg);
      } else {
        drawNormal(text, bg);
      }
    }

    /* ========= MODO NORMAL (Felt Tip Roman, centrado) ========= */
    function drawNormal(text, bg) {
      ctx.save();

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getContrastColor(bg);

      const maxFont = 80;
      const minFont = 36;
      const maxWidth = CANVAS_SIZE - 2 * PADDING;
      let fontSize = maxFont;
      let lines = [];

      while (fontSize > minFont) {
        ctx.font = fontSize + "px 'Felt Tip Roman', cursive";
        lines = wrapText(text, maxWidth, ctx);
        const totalHeight = lines.length * fontSize * 1.2;
        if (totalHeight <= CANVAS_SIZE - 2 * PADDING) {
          break;
        }
        fontSize -= 4;
      }

      ctx.font = fontSize + "px 'Felt Tip Roman', cursive";
      lines = wrapText(text, maxWidth, ctx);
      const totalHeight = lines.length * fontSize * 1.2;
      let y = CANVAS_SIZE / 2 - totalHeight / 2 + fontSize * 0.1;

      for (const line of lines) {
        ctx.fillText(line, CANVAS_SIZE / 2, y);
        y += fontSize * 1.2;
      }

      ctx.restore();
    }

    /* ========= MODO BRAT (Arial Narrow, bloque centrado + justificado + blur) ========= */
    function drawBrat(text, bg) {
      ctx.save();

      const textColor = getContrastColor(bg);
      const innerWidth = CANVAS_SIZE - 2 * PADDING;
      const maxHeight = CANVAS_SIZE - PADDING * 2; // altura permitida del bloque
      const maxFont = 200;
      const minFont = 40;

      let low = minFont;
      let high = maxFont;
      let bestFont = minFont;
      let bestLines = [];

      // B√∫squeda binaria para encontrar el tama√±o de fuente ideal
      while (low <= high) {
        const mid = (low + high) >> 1;
        ctx.font = mid + "px 'Archivo Narrow', sans-serif";

        const candidateLines = wrapWordsToLines(text, innerWidth, ctx);
        const totalHeight = candidateLines.length * mid * 1.1;

        if (totalHeight <= maxHeight) {
          bestFont = mid;
          bestLines = candidateLines;
          low = mid + 4;
        } else {
          high = mid - 4;
        }
      }

      ctx.font = `600 ${bestFont}px 'Archivo Narrow', sans-serif`;
      ctx.textBaseline = "top";
      ctx.fillStyle = textColor;
      const lineHeight = bestFont * 1.06;

      // üî• CENTRAR BLOQUE VERTICALMENTE
      const blockHeight = bestLines.length * lineHeight;
      let y = (CANVAS_SIZE - blockHeight) / 2;

      // Dibujar l√≠neas justificado + blur
      bestLines.forEach((words, idx) => {
        const isLast = idx === bestLines.length - 1;
        drawJustifiedLine(words, PADDING, y, innerWidth, isLast, ctx);
        y += lineHeight;
      });

      ctx.restore();
    }

    /* ========= UTILIDADES DE TEXTO ========= */

    function wrapText(text, maxWidth, ctxLocal) {
      const words = text.split(/\s+/);
      const lines = [];
      let line = "";

      for (const w of words) {
        const testLine = line ? line + " " + w : w;
        const { width } = ctxLocal.measureText(testLine);
        if (width > maxWidth && line) {
          lines.push(line);
          line = w;
        } else {
          line = testLine;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    // Para brat: cada l√≠nea es array de palabras
    function wrapWordsToLines(text, maxWidth, ctxLocal) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let current = [];

      words.forEach(w => {
        const test = [...current, w].join(" ");
        const { width } = ctxLocal.measureText(test);
        if (width > maxWidth && current.length > 0) {
          lines.push(current);
          current = [w];
        } else {
          current.push(w);
        }
      });

      if (current.length) lines.push(current);
      return lines;
    }

    function drawJustifiedLine(words, x, y, lineWidth, isLast, ctx) {
      if (!words || words.length === 0) return;

      // Siempre justificar, incluso la √∫ltima l√≠nea (como Bratgenerator)
      if (words.length === 1) {
        ctx.filter = "blur(5px)";
        ctx.fillText(words[0], x, y);
        ctx.filter = "none";
        return;
      }

      const wordsWidth = words.reduce(
        (acc, w) => acc + ctx.measureText(w).width,
        0
      );

      const totalSpaces = words.length - 1;
      const extraSpaceTotal = lineWidth - wordsWidth;
      const spaceSize = extraSpaceTotal / totalSpaces;

      let cursorX = x;
      ctx.filter = "blur(5px)";

      for (let i = 0; i < words.length; i++) {
        const w = words[i];
        ctx.fillText(w, cursorX, y);
        if (i < words.length - 1) {
          cursorX += ctx.measureText(w).width + spaceSize;
        }
      }

      ctx.filter = "none";
    }


    
    /* ========= WATERMARK DIAGONAL ========= */
    function drawWatermark() {
      ctx.save();
      ctx.globalAlpha = 0.07;
      ctx.fillStyle = getContrastColor(bgColorInput.value);
      ctx.font = "200px 'Archivo Narrow', sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
      ctx.rotate(-0.6);
      ctx.filter = "blur(5px)";
      ctx.fillText("@nachozorra", 0, 0);
      ctx.restore();
    }

    /* ========= PLACEHOLDER ========= */
    function drawPlaceholder() {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.font = "42px 'Felt Tip Roman', cursive";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        "v6 ü¶ä",
        CANVAS_SIZE / 2,
        CANVAS_SIZE / 2
      );
      ctx.restore();
    }

    /* ========= CONTRASTE ========= */
    function getContrastColor(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 150 ? "#000000" : "#ffffff";
    }

    /* ========= DESCARGAR ========= */
    function downloadPNG() {
      const link = document.createElement("a");
      const mode = toggle.checked ? "brat" : "normal";
      link.download = "nachozorra_" + mode + "_" + Date.now() + ".png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }

    function generateMultiple() {
      const raw = input.value;
      const phrases = raw.split(";").map(t => t.trim()).filter(t => t.length > 0);

      if (phrases.length <= 1) {
        alert("Escribe varias frases separadas por ;");
        return;
      }

      let index = 0;
      const original = raw;

      function next() {
        if (index >= phrases.length) {
          input.value = original;
          draw();
          alert("Listo: todas las im√°genes fueron generadas.");
          return;
        }

        const phrase = phrases[index];
        input.value = phrase;
        draw();

        // Esperamos 200ms para asegurar que el texto ya est√° renderizado
        setTimeout(() => {
          const link = document.createElement("a");
          link.download = "frase_" + (index + 1) + ".png";
          link.href = canvas.toDataURL("image/png");
          link.click();

          index++;
          next();
        }, 250);
      }

      next();
    }

    
  </script>

</body>
</html>

