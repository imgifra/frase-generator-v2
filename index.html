<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NachoZorra Generator ü¶ä</title>

  <!-- Fuentes -->
  <link href="https://fonts.cdnfonts.com/css/felt-tip-roman" rel="stylesheet">
  <link href="https://fonts.cdnfonts.com/css/arial-narrow" rel="stylesheet">

  <!-- Tailwind para layout de controles -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root {
      --controls-h: 110px;
    }

    body {
      background: #111;
      margin: 0;
      color: #fff;
      font-family: 'Felt Tip Roman', cursive;
      overflow: hidden;
    }

    /* √Årea de preview */
    #stage {
      height: calc(100vh - var(--controls-h));
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #previewCanvas {
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      border-radius: 25px;
      background: #fff;
      display: block;
    }

    /* Panel de control inferior */
    .control-panel {
      position: fixed;
      bottom: 0;
      width: 100%;
      height: var(--controls-h);
      background: rgba(0,0,0,0.88);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      z-index: 20;
      padding-bottom: 6px;
    }

    /* Switch tipo iPhone */
    .switch {
      position: relative;
      width: 55px;
      height: 28px;
    }
    .switch input {
      display: none;
    }
    .slider {
      position: absolute;
      inset: 0;
      cursor: pointer;
      background-color: #555;
      border-radius: 34px;
      transition: .3s;
    }
    .slider:before {
      content: "";
      position: absolute;
      width: 22px;
      height: 22px;
      left: 3px;
      bottom: 3px;
      background: #fff;
      border-radius: 50%;
      transition: .3s;
    }
    input:checked + .slider {
      background-color: #22c55e;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }

    /* Input de color */
    #bgColor {
      width: 34px;
      height: 34px;
      padding: 0;
      border-radius: 999px;
      border: none;
      overflow: hidden;
    }
    #bgColor::-webkit-color-swatch,
    #bgColor::-moz-color-swatch {
      border: none;
      border-radius: 999px;
    }
  </style>
</head>
<body>

  <main id="stage">
    <canvas id="previewCanvas" width="1080" height="1080"></canvas>
  </main>

  <!-- Controles -->
  <div class="control-panel">
    <!-- Modo -->
    <div class="flex items-center justify-center gap-3 text-sm">
      <span>Modo:</span>
      <label class="switch">
        <input type="checkbox" id="modeToggle">
        <span class="slider"></span>
      </label>
      <span id="modeLabel">Normal</span>
    </div>

    <!-- Texto + fondo + bot√≥n -->
    <div class="flex items-center justify-center gap-3 w-full px-3">
      <input
        id="textInput"
        type="text"
        placeholder="Escribe tu frase..."
        class="flex-1 p-2 rounded-lg text-black text-center font-bold text-lg outline-none"
      >

      <div class="flex items-center gap-1 text-sm">
        <span>Fondo:</span>
        <input type="color" id="bgColor" value="#ffffff">
      </div>

      <button
        id="downloadBtn"
        class="px-5 py-2 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 active:bg-indigo-800"
      >
        Descargar PNG
      </button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("previewCanvas");
    const ctx = canvas.getContext("2d");

    const input = document.getElementById("textInput");
    const bgColorInput = document.getElementById("bgColor");
    const toggle = document.getElementById("modeToggle");
    const modeLabel = document.getElementById("modeLabel");
    const downloadBtn = document.getElementById("downloadBtn");

    const CANVAS_SIZE = 1080;
    const PADDING = 80;

    let fontsReady = false;

    document.addEventListener("DOMContentLoaded", init);

    async function init() {
      await loadFonts();   // ‚¨ÖÔ∏è aqu√≠ esperamos espec√≠ficamente las 2 fuentes
      fontsReady = true;
      draw();

      input.addEventListener("input", draw);
      bgColorInput.addEventListener("input", draw);
      toggle.addEventListener("change", () => {
        modeLabel.textContent = toggle.checked ? "Brat" : "Normal";
        draw();
      });
      downloadBtn.addEventListener("click", downloadPNG);
    }

    async function loadFonts() {
      if (!document.fonts || !document.fonts.load) {
        // Fallback si el navegador no soporta document.fonts
        await new Promise(res => setTimeout(res, 500));
        return;
      }

      try {
        const p1 = document.fonts.load('60px "Felt Tip Roman"');
        const p2 = document.fonts.load('120px "Arial Narrow"');
        const p3 = document.fonts.ready;
        await Promise.all([p1, p2, p3]);
      } catch (e) {
        // Si algo falla, igual seguimos y el navegador usar√° fallback
        console.warn("Error cargando fuentes, usando fallback:", e);
      }
    }

    function draw() {
      if (!fontsReady) return;

      const text = input.value.trim();
      const bg = bgColorInput.value;

      // Fondo
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      // Marca de agua primero (queda detr√°s de la frase)
      drawWatermark();

      if (!text) {
        drawPlaceholder();
        return;
      }

      if (toggle.checked) {
        drawBrat(text, bg);
      } else {
        drawNormal(text, bg);
      }
    }

    /* ===== MODO NORMAL (Felt Tip Roman, centrado) ===== */
    function drawNormal(text, bg) {
      ctx.save();

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getContrastColor(bg);

      const maxFont = 80;
      const minFont = 36;
      const maxWidth = CANVAS_SIZE - 2 * PADDING;
      let fontSize = maxFont;
      let lines = [];

      while (fontSize > minFont) {
        ctx.font = fontSize + 'px "Felt Tip Roman"';
        lines = wrapText(text, maxWidth, ctx);
        const totalHeight = lines.length * fontSize * 1.2;
        if (totalHeight <= CANVAS_SIZE - 2 * PADDING) break;
        fontSize -= 4;
      }

      ctx.font = fontSize + 'px "Felt Tip Roman"';
      lines = wrapText(text, maxWidth, ctx);
      const totalHeight = lines.length * fontSize * 1.2;
      let y = CANVAS_SIZE / 2 - totalHeight / 2 + fontSize * 0.1;

      for (const line of lines) {
        ctx.fillText(line, CANVAS_SIZE / 2, y);
        y += fontSize * 1.2;
      }

      ctx.restore();
    }

    /* ===== MODO BRAT (Arial Narrow, bloque centrado + justificado + blur) ===== */
    function drawBrat(text, bg) {
      ctx.save();

      const textColor = getContrastColor(bg);
      const innerWidth = CANVAS_SIZE - 2 * PADDING;
      const maxHeight = CANVAS_SIZE * 0.75;
      const maxFont = 200;
      const minFont = 40;

      let low = minFont;
      let high = maxFont;
      let bestFont = minFont;
      let bestLines = [];

      // B√∫squeda binaria para tama√±o de fuente
      while (low <= high) {
        const mid = (low + high) >> 1;
        ctx.font = mid + 'px "Arial Narrow"';
        const candidateLines = wrapWordsToLines(text, innerWidth, ctx);
        const totalHeight = candidateLines.length * mid * 1.1;

        if (totalHeight <= maxHeight) {
          bestFont = mid;
          bestLines = candidateLines;
          low = mid + 4;
        } else {
          high = mid - 4;
        }
      }

      ctx.font = bestFont + 'px "Arial Narrow"';
      ctx.textBaseline = "top";
      ctx.fillStyle = textColor;
      const lineHeight = bestFont * 1.1;

      // Centrar verticalmente el bloque de texto
      const blockHeight = bestLines.length * lineHeight;
      let y = (CANVAS_SIZE - blockHeight) / 2;

      bestLines.forEach((words, idx) => {
        const isLast = idx === bestLines.length - 1;
        drawJustifiedLine(words, PADDING, y, innerWidth, isLast, ctx);
        y += lineHeight;
      });

      ctx.restore();
    }

    /* ===== UTILIDADES DE TEXTO ===== */

    function wrapText(text, maxWidth, ctx) {
      const words = text.split(/\s+/);
      const lines = [];
      let line = "";

      for (const w of words) {
        const testLine = line ? line + " " + w : w;
        const { width } = ctx.measureText(testLine);
        if (width > maxWidth && line) {
          lines.push(line);
          line = w;
        } else {
          line = testLine;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    // Para brat: cada l√≠nea es un array de palabras
    function wrapWordsToLines(text, maxWidth, ctx) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let current = [];

      words.forEach(w => {
        const test = [...current, w].join(" ");
        const { width } = ctx.measureText(test);
        if (width > maxWidth && current.length > 0) {
          lines.push(current);
          current = [w];
        } else {
          current.push(w);
        }
      });

      if (current.length) lines.push(current);
      return lines;
    }

    function drawJustifiedLine(words, x, y, lineWidth, isLast, ctxLocal) {
      if (words.length === 0) return;

      const baseSpace = ctxLocal.measureText(" ").width;

      if (isLast || words.length === 1) {
        // √öltima l√≠nea: normal, no hiperjustificar
        let cursorX = x;
        ctxLocal.filter = "blur(3px)";
        for (let i = 0; i < words.length; i++) {
          const w = words[i];
          ctxLocal.fillText(w, cursorX, y);
          cursorX += ctxLocal.measureText(w).width + baseSpace;
        }
        ctxLocal.filter = "none";
        return;
      }

      const wordsWidth = words.reduce(
        (acc, w) => acc + ctxLocal.measureText(w).width,
        0
      );
      const totalSpaces = words.length - 1;
      const extraSpaceTotal = lineWidth - wordsWidth;
      const spaceSize = extraSpaceTotal / totalSpaces;

      let cursorX = x;
      ctxLocal.filter = "blur(3px)";

      for (let i = 0; i < words.length; i++) {
        const w = words[i];
        ctxLocal.fillText(w, cursorX, y);
        if (i < words.length - 1) {
          cursorX += ctxLocal.measureText(w).width + spaceSize;
        }
      }

      ctxLocal.filter = "none";
    }

    /* ===== WATERMARK DIAGONAL ===== */
    function drawWatermark() {
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = "#000";
      ctx.font = '260px "Arial Narrow"';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
      ctx.rotate(-0.6);
      ctx.filter = "blur(3px)";
      ctx.fillText("@nachozorra", 0, 0);
      ctx.restore();
    }

    /* ===== PLACEHOLDER ===== */
    function drawPlaceholder() {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.font = '42px "Felt Tip Roman"';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(
        "Escribe algo abajo para generar ü¶ä",
        CANVAS_SIZE / 2,
        CANVAS_SIZE / 2
      );
      ctx.restore();
    }

    /* ===== CONTRASTE ===== */
    function getContrastColor(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.slice(0, 2), 16);
      const g = parseInt(hex.slice(2, 4), 16);
      const b = parseInt(hex.slice(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 150 ? "#000000" : "#ffffff";
    }

    /* ===== DESCARGAR ===== */
    function downloadPNG() {
      const link = document.createElement("a");
      const mode = toggle.checked ? "brat" : "normal";
      link.download = "nachozorra_" + mode + "_" + Date.now() + ".png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }
  </script>

</body>
</html>
